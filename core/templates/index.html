<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backgammon Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            background-color: #eee;
            margin-top: 20px;
            border: 1px solid #333;
        }

        #controls {
            margin-top: 10px;
        }

        button {
            margin: 0 5px;
            padding: 8px 15px;
            font-size: 16px;
        }
    </style>
</head>
<body>

<h2>Backgammon Game</h2>
<canvas id="myCanvas"></canvas>
<div id="controls">
    <button id="resetButton">Reset</button>
    <button id="undoButton">Undo</button>
    <span id="statusInfo"></span>
</div>

<script>
    // ========== GLOBALS ==========
    const CELL_SIZE = 60; 

    var canvas, ctx;
    var gameId;
    var rollButton = {onScreen: false};
    var takeButton = {onScreen: false};
    var passButton = {onScreen: false};
    var startButton = {onScreen: false};

    var Cube = {position: "center", value: 1, onScreen: false};
    var Dices = {position: "", diceValueLeft: 5, diceValueRight: 5, onScreen: false};

    var Board = {
        width: window.innerWidth * 3 / 4 < window.innerHeight ? window.innerWidth - 20 : window.innerHeight * 4 / 3 * 0.9,
        reset: function () {
            this.p24 = [2, 0];
            this.p23 = [0, -1];
            this.p22 = [0, -1];
            this.p21 = [0, -1];
            this.p20 = [0, -1];
            this.p19 = [5, 1];
            this.p18 = [0, -1];
            this.p17 = [3, 1];
            this.p16 = [0, -1];
            this.p15 = [0, -1];
            this.p14 = [0, -1];
            this.p13 = [5, 0];
            this.p12 = [5, 1];
            this.p11 = [0, -1];
            this.p10 = [0, -1];
            this.p9 = [0, -1];
            this.p8 = [3, 0];
            this.p7 = [0, -1];
            this.p6 = [5, 0];
            this.p5 = [0, -1];
            this.p4 = [0, -1];
            this.p3 = [0, -1];
            this.p2 = [0, -1];
            this.p1 = [2, 1];
            this.offWhite = [0, 1];
            this.offBlack = [0, 0];
            this.barWhite = [0, 1];
            this.barBlack = [0, 0];
            this.status = "start";
            this.onMove = "black";
            this.moves = [];
            this.playedMoves = [];
            Cube.position = "center";
            Cube.value = 1;
            rollButton.onScreen = false;
            Dices.onScreen = false;
            takeButton.onScreen = false;
            passButton.onScreen = false;
        },
        save: function () {
            for (var i = 1; i <= 24; i++) this["b" + i] = this["p" + i].slice();
            this.bOffWhite = this.offWhite.slice();
            this.bOffBlack = this.offBlack.slice();
            this.bBarWhite = this.barWhite.slice();
            this.bBarBlack = this.barBlack.slice();
            this.bMoves = this.moves.slice();
        },
        undo: function () {
            for (var i = 1; i <= 24; i++) this["p" + i] = this["b" + i].slice();
            this.offWhite = this.bOffWhite.slice();
            this.offBlack = this.bOffBlack.slice();
            this.barWhite = this.bBarWhite.slice();
            this.barBlack = this.bBarBlack.slice();
            this.moves = this.bMoves.slice();
            this.playedMoves = [];
        },
        mouseOverPoint: undefined
    };

    // ====================== DRAW BOARD FUNCTION ======================
    function drawBoard(brd) {
        var boardBorderColor = "#663300";
        var boardInnerColor = "#B88A00";
        var triangleColor1 = "#ADAD85";
        var triangleColor2 = "#FF471A";
        var triangleBorderColor = "#444";
        var blackCheckerColor = "#333";
        var whiteCheckerColor = "#DDD";
        var cubeBodyColor = "#DDD";
        var cubeNumberColor = "#333";
        var buttonBackgroundColor = "#FCBD00";
        var buttonBorderColor = "#333";
        var buttonTextColor = "#FD3200";
        var blackDiceBodyColor = "#333";
        var blackDiceDotColor = "#DDD";
        var whiteDiceBodyColor = "#DDD";
        var whiteDiceDotColor = "#333";
        var w = brd.width;
        var h = w * 3 / 4;
        var p = 0.02; //the board is sliced to 50 pitches both vertically and horizontally
        canvas.width = w;
        canvas.height = h;
        drawEmptyBoard();
        // draw checkers to the 24 points
        for (var i = 1; i <= 24; i++) drawPoint(i, brd["p" + i]);
        drawCheckersOnTheBar();
        drawCheckersBearedOff();
        drawCube(Cube);
        drawRest();

        function Button(x, y, width, height, text) {
            this.x = x;  //take care, x and y specifiy the center of the button!
            this.y = y;
            this.width = width;
            this.height = height;
            this.text = text;
            this.backgroundColor = buttonBackgroundColor;
            this.borderColor = buttonBorderColor;
            this.textColor = buttonTextColor;
            this.onScreen = false;
        }

        function drawEmptyBoard() {
            // draw board frame
            ctx.save();
            ctx.fillStyle = boardBorderColor;
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = boardInnerColor;
            ctx.fillRect(w * p, h * p * 2, w * p * 3, h * p * 20); //top left holder
            ctx.fillRect(w * p, h * p * 28, w * p * 3, h * p * 20); //bottom left holder
            ctx.fillRect(w * p * 46, h * p * 2, w * p * 3, h * p * 20); //top right holder
            ctx.fillRect(w * p * 46, h * p * 28, w * p * 3, h * p * 20); //bottom right holder
            ctx.fillRect(w * p * 5, h * p * 2, w * p * 18, h * p * 46); //left board
            ctx.fillRect(w * p * 27, h * p * 2, w * p * 18, h * p * 46); //right board
            // draw the 24 triangles
            for (var i = 0; i <= 5; i++) {
                drawTriangle(5 + i * 3, 2, 3, 20, i % 2); //top left tiangs
                drawTriangle(5 + i * 3, 48, 3, 20, (i + 1) % 2); //bottom left triangs
                drawTriangle(27 + i * 3, 2, 3, 20, i % 2); //top right triangs
                drawTriangle(27 + i * 3, 48, 3, 20, (i + 1) % 2); //bottom right triangs
            }
            ctx.restore();

            function drawTriangle(startx, starty, width, height, color) {
                var peak;
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(w * p * startx, h * p * starty);
                peak = starty < 25 ? starty + height : starty - height;
                ctx.lineTo(w * p * (startx + width / 2), h * p * peak);
                ctx.lineTo(w * p * (startx + width), h * p * starty);
                ctx.fillStyle = color == 0 ? triangleColor1 : triangleColor2;
                ctx.strokeStyle = triangleBorderColor;
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        }

        function drawPoint(j, point) {
            if (point[1] == -1 || point[0] == 0) return;
            var color;
            color = point[1] == 0 ? blackCheckerColor : whiteCheckerColor;
            var centerx, centery;
            var numCheckers = Math.min(point[0], 5);
            for (var i = 0; i < numCheckers; i++) {
                if (j >= 19) {
                    centerx = w * p * (28.5 + (j - 19) * 3);
                    centery = 2 * h * p + 1.5 * w * p + i * 3 * w * p;
                } else if (j >= 13) {
                    centerx = w * p * (6.5 + (j - 13) * 3);
                    centery = 2 * h * p + 1.5 * w * p + i * 3 * w * p;
                } else if (j >= 7) {
                    centerx = w * p * (6.5 + (12 - j) * 3);
                    centery = 48 * h * p - 1.5 * w * p - i * 3 * w * p;
                } else {
                    centerx = w * p * (28.5 + (6 - j) * 3);
                    centery = 48 * h * p - 1.5 * w * p - i * 3 * w * p;
                }
                drawChecker(centerx, centery, color, (j == brd.mouseOverPoint && i == numCheckers - 1 && brd.status == "move" && point[1] == (brd.onMove == "black" ? 0 : 1)));
            }
            if (point[0] > 5) {  //draw number to the last checker if they are more then 5
                ctx.save();
                ctx.fillStyle = color == blackCheckerColor ? whiteCheckerColor : blackCheckerColor;
                ctx.font = w * p * 1.8 + "px Arial";
                ctx.textBaseline = "middle";
                ctx.textAlign = "center";
                ctx.fillText(point[0].toString(), centerx, centery);
                ctx.restore();
            }
        }

        function drawChecker(x, y, col, hl) {
            hl = hl || false;
            var r = w * p * 1.5;
            ctx.save();
            ctx.beginPath();
            if (hl) { //highlight of the active checker by elevating it
                r *= 1.05;
                addShadow();
            }
            ctx.arc(x, y, r * 0.99, 0, 2 * Math.PI);
            ctx.fillStyle = col;
            ctx.fill();
            ctx.restore();
            ctx.stroke();

            function addShadow() {
                ctx.shadowColor = "#444"; // color
                ctx.shadowBlur = 5; // blur level
                ctx.shadowOffsetX = r * 0.2; // horizontal offset
                ctx.shadowOffsetY = r * 0.2; // vertical offset
            }
        }

        function drawCheckersOnTheBar() {
            var x = w * p * 25;
            var y, color;
            for (var i = 0; i < brd.barBlack[0]; i++) {
                y = h * p * 18 - i * w * p * 3;
                color = blackCheckerColor;
                drawChecker(x, y, color, (brd.mouseOver == "barBlack" && i == brd.barBlack[0] - 1 && brd.status == "move" && brd.onMove == "black"));
            }
            for (var i = 0; i < brd.barWhite[0]; i++) {
                y = h * p * 32 + i * w * p * 3;
                color = whiteCheckerColor;
                drawChecker(x, y, color, (brd.mouseOver == "barWhite" && i == brd.barWhite[0] - 1 && brd.status == "move" && brd.onMove == "white"));
            }
        }

        function drawCheckersBearedOff() {
            ctx.save();
            ctx.fillStyle = blackCheckerColor;
            ctx.lineWidth = 2;
            for (var i = 1; i <= brd.offBlack[0]; i++) {
                ctx.fillRect(w * p * 46, h * p * (48 - i * 4 / 3), w * p * 3, h * p * 4 / 3);
                ctx.strokeRect(w * p * 46, h * p * (48 - i * 4 / 3), w * p * 3, h * p * 4 / 3);
            }
            ctx.fillStyle = whiteCheckerColor;
            for (var i = 0; i < brd.offWhite[0]; i++) {
                ctx.fillRect(w * p * 46, h * p * (2 + i * 4 / 3), w * p * 3, h * p * 4 / 3);
                ctx.strokeRect(w * p * 46, h * p * (2 + i * 4 / 3), w * p * 3, h * p * 4 / 3);
            }
            ctx.restore();
        }

        function drawCube(cb) {
            if (cb.position == "off") return;
            cb.x = w * p * 2.5;  // x and y specify the center of the cube
            cb.y = h * p * 25;
            cb.angle = 0;
            cb.size = w * p * 3 * 0.95;
            cb.fontsize = cb.size * 0.7 + "px";
            var nr = cb.value == 1 ? "64" : cb.value.toString();
            if (cb.position == "center") {
                cb.angle = Math.PI * 1.5;
            } else if (cb.position == "black") {
                cb.y = h * p * 48 - cb.size / 2;
            } else if (cb.position == "white") {
                cb.y = h * p * 2 + cb.size / 2;
                cb.angle = Math.PI;
            } else if (cb.position == "right") {
                cb.x = w * p * 36;
                cb.angle = Math.PI;
            } else if (cb.position == "left") {
                cb.x = w * p * 14;
            }
            ctx.save();
            ctx.fillStyle = cubeBodyColor;
            ctx.translate(cb.x, cb.y);
            ctx.rotate(cb.angle);
            ctx.translate(-cb.size / 2, -cb.size / 2);
            roundRect(ctx, 0, 0, cb.size, cb.size, cb.size * 0.05, true, true);
            ctx.fillStyle = cubeNumberColor;
            ctx.font = "bold " + cb.fontsize + " Arial";
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            ctx.fillText(nr, cb.size / 2, cb.size / 2);
            ctx.restore();
            cb.onScreen = true;
        }

        function drawRest() {
            if (brd.status == "roll") drawRollButton();
            else if (brd.status == "move") drawDices();
            else if (brd.status == "accept") drawAcceptButton();
            else if (brd.status == "start") drawStartButton();

            function drawRollButton() {
                rollButton = new Button(0, h * p * 25, w * p * 6, h * p * 3, "ROLL");
                rollButton.x = brd.onMove == "black" ? w * p * 36 : w * p * 14;
                drawButton(rollButton);
            }

            function drawStartButton() {
                startButton = new Button(w * p * 25, h * p * 25, w * p * 8, h * p * 4, "START");
                drawButton(startButton);
            }

            function drawDices() {
                var x = brd.onMove == "black" ? w * p * 35.5 - h * p * 4 : w * p * 14.5;
                var y = h * p * 23;
                Dices.position = brd.onMove == "black" ? "right" : "left";
                var diceColor = brd.onMove == "black" ? blackDiceBodyColor : whiteDiceBodyColor;
                var dotColor = brd.onMove == "black" ? blackDiceDotColor : whiteDiceDotColor;
                drawDice(ctx, x, y, h * p * 4, Dices.diceValueLeft, diceColor, dotColor);
                x = brd.onMove == "black" ? x + h * p * 4 + w * p : x - h * p * 4 - w * p;
                drawDice(ctx, x, y, h * p * 4, Dices.diceValueRight, diceColor, dotColor);
                Dices.onScreen = true;

                function drawDice(ctx, x, y, size, value, diceColor, dotColor) {
                    /*  This function draws a dice to the canvas.
                    ctx is the canvas context
                    x, y are the coordinates of the top left corner of the dice
                    size is the length of the dice size in px
                    value is the value of the dice. It shall be between 1 and 6
                    diceColor and DotColor are color of the dice body and of the dots on it respectively
                    the roundRect function is not part of the function but it shall be in the code as well  */
                    dots = [];
                    ctx.save();
                    ctx.fillStyle = diceColor;
                    ctx.translate(x, y);
                    roundRect(ctx, 0, 0, size, size, size * 0.1, true, false);

                    //define dot locations
                    var padding = 0.25;
                    var x, y;
                    x = padding * size;
                    y = padding * size;
                    dots.push({x: x, y: y});
                    y = size * 0.5;
                    dots.push({x: x, y: y});
                    y = size * (1 - padding);
                    dots.push({x: x, y: y});
                    x = size * 0.5;
                    y = size * 0.5;
                    dots.push({x: x, y: y});
                    x = size * (1 - padding);
                    y = padding * size;
                    dots.push({x: x, y: y});
                    y = size * 0.5;
                    dots.push({x: x, y: y});
                    y = size * (1 - padding);
                    dots.push({x: x, y: y});

                    var dotsToDraw;
                    if (value == 1) dotsToDraw = [3];
                    else if (value == 2) dotsToDraw = [0, 6];
                    else if (value == 3) dotsToDraw = [0, 3, 6];
                    else if (value == 4) dotsToDraw = [0, 2, 4, 6];
                    else if (value == 5) dotsToDraw = [0, 2, 3, 4, 6];
                    else if (value == 6) dotsToDraw = [0, 1, 2, 4, 5, 6];
                    else console.log("Dice value shall be between 1 and 6");

                    ctx.fillStyle = dotColor;
                    for (var i = 0; i < dotsToDraw.length; i++) {
                        ctx.beginPath();
                        var j = dotsToDraw[i];
                        ctx.arc(dots[j].x, dots[j].y, size * 0.07, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }

            function drawAcceptButton() {
                takeButton = new Button(0, h * p * 25, w * p * 6, h * p * 3, "TAKE");
                passButton = new Button(0, h * p * 25, w * p * 6, h * p * 3, "PASS");
                takeButton.x = brd.onMove == "black" ? w * p * 36 - takeButton.width / 2 - w * p / 2 : w * p * 14 + takeButton.width / 2 + w * p / 2;
                passButton.x = brd.onMove == "black" ? w * p * 36 + takeButton.width / 2 + w * p / 2 : w * p * 14 - takeButton.width / 2 - w * p / 2;
                drawButton(takeButton);
                drawButton(passButton);
            }
        }

        function drawButton(btn) {
            btn.onScreen = true;
            var angle = brd.onMove == "black" ? 0 : Math.PI;
            var fontsize = parseInt(btn.height * 0.7).toString() + "px";
            ctx.save();
            ctx.translate(btn.x, btn.y);
            ctx.rotate(angle);
            ctx.translate(-btn.width / 2, -btn.height / 2);
            ctx.fillStyle = btn.backgroundColor;
            ctx.strokeStyle = btn.borderColor;
            roundRect(ctx, 0, 0, btn.width, btn.height, h * p * 0.7, true, true);
            ctx.fillStyle = btn.textColor;
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            ctx.font = "bold " + fontsize + " Arial";
            ctx.fillText(btn.text, btn.width / 2, btn.height / 2);
            ctx.restore();
        }

        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke == 'undefined') {
                stroke = true;
            }
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            if (typeof radius === 'number') {
                radius = {
                    tl: radius,
                    tr: radius,
                    br: radius,
                    bl: radius
                };
            } else {
                var defaultRadius = {
                    tl: 0,
                    tr: 0,
                    br: 0,
                    bl: 0
                };
                for (var side in defaultRadius) {
                    radius[side] = radius[side] || defaultRadius[side];
                }
            }
            ctx.beginPath();
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + width - radius.tr, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
            ctx.lineTo(x + width, y + height - radius.br);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
            ctx.lineTo(x + radius.bl, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }
    }

    // ====================== UPDATE BOARD FROM API ======================
    function updateBoardFromAPI(data) {
        for (let i = 1; i <= 24; i++) Board["p" + i] = data.board?.["p" + i] || Board["p" + i];
        Board.offWhite = data.board?.offWhite || Board.offWhite;
        Board.offBlack = data.board?.offBlack || Board.offBlack;
        Board.barWhite = data.board?.barWhite || Board.barWhite;
        Board.barBlack = data.board?.barBlack || Board.barBlack;
        Board.status = data.board?.status || Board.status;
        Board.onMove = data.board?.onMove || Board.onMove;
        Dices.diceValueLeft = data.dice?.[0] || Dices.diceValueLeft;
        Dices.diceValueRight = data.dice?.[1] || Dices.diceValueRight;
        Cube.value = data.cube?.value || Cube.value;
        Cube.position = data.cube?.position || Cube.position;
        drawBoard(Board);
    }

    // ====================== INIT ======================


    async function init() {
        canvas = document.getElementById('myCanvas');
        ctx = canvas.getContext('2d');

        // بازی قبلی را از localStorage بخوانید
        let storedGameId = localStorage.getItem("gameId");

        if (storedGameId) {
            gameId = storedGameId;
            const current = await fetch(`http://127.0.0.1:8000/game/games/${gameId}/`);
            const data = await current.json();
            updateBoardFromAPI(data);
        } else {
            const res = await fetch("http://127.0.0.1:8000/game/games/", {
                method: "POST",
                headers: {"Content-Type": "application/json"}
            });
            const data = await res.json();
            gameId = data.id;
            localStorage.setItem("gameId", gameId); // ذخیره gameId
            updateBoardFromAPI(data);
        }

        // ==========================
        // EVENT HANDLERS
        // ==========================
        canvas.addEventListener("mousemove", handleMousemove);
        canvas.addEventListener("click", handleMouseclick);

        document.getElementById("resetButton").onclick = async function () {
            const res = await fetch("http://127.0.0.1:8000/game/games/", {method: "POST"});
            const newGame = await res.json();
            gameId = newGame.id;
            localStorage.setItem("gameId", gameId);
            updateBoardFromAPI(newGame);
        };

        document.getElementById("undoButton").onclick = async function () {
            if (Board.status == "move" && Board.playedMoves.length > 0) {
                const res = await fetch(`http://127.0.0.1:8000/game/games/${gameId}/`, {method: "GET"});
                const current = await res.json();
                updateBoardFromAPI(current);
            }
        };

        document.getElementById("statusInfo").innerHTML = "Init done (API connected)";
    }

    // ==========================
    // تابع حرکت مهره با کلیک
    // ==========================
    async function handleMouseclick(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const row = Math.floor(y / CELL_SIZE);
        const col = Math.floor(x / CELL_SIZE);

        const movePayload = {row: row, col: col}; // مطابق با API شما

        const res = await fetch(`http://127.0.0.1:8000/game/games/${gameId}/move/`, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(movePayload)
        });

        const data = await res.json();
        updateBoardFromAPI(data);
    }

    // تابع نمونه برای موس (می‌تونید بعدا پر کنید)
    function handleMousemove(e) {
        // hover یا highlight
    }

    // ====================== START ======================
    Board.reset();
    init();
</script>

</body>
</html>
